* 0L design

** State

- State is a list of maps with 3 keys: ~[{:ui nil :io nil :data nil}]~
- Cache invalidataion - as ~data~ is just a cached data of some remote
  storage we have to think about invalidation of that. For that we
  store ~:age~ of each piece of data. Meaning data is:
#+BEGIN_SRC clojure
{:data {:message {:sender "John" :content {:subject "Hello" :body "Hello ..."}}}}
;; Is actually stored like that
{:data [{:age {:sid "uuid:1231312" :time "00:00:00 00:00" :source :disk}  :executer :rule-name-a :data {:message {:sender "John" :content {:subject "Hello" :draft true}}}}
        {:age {:sid "uuid:0909090" :time "23:11:11 12.112" :source :http} :executer :rule-name-b :data {:message {:content {:body "Hello ..."}}}}
        {:age {:sid "uuid:0909090" :time "23:11:23 45.891" :source :http} :executer :rule-name-c :data {:message {:content {:draft nil}}}}]}
#+END_SRC
- ~io~ should return new ~:age~ for data
- As each piece of data has an age which includes ~:source~ we can
  skip everything that we fetched from disk or add something else:
  ~:persist-forever|:persist-never|:can-be-purged|:cheap-call|:tmp~
- Relation between data parts: ~f(:data) -> [:ui,:io]~. Meaning that ~ui~ and ~io~ are created from data
- While ~ui~ and ~io~ is derivative of data, still ~data~ is just a
  RAM cache and not a reliable storage
- Persiting state - only ~data~ has to be saved in order to recover
  application. It allows in a feature to sync data between different
  clients if we wish (desktop big ~data~ state could be easily
  rendered on a small phone screen)

** Questions

- Modes: Should ~modes~ be part of components props?

- We tend to think about handling UI as a `f(event) ->
  reaction`. Because computation is delayed until the actual event -
  we have a latency which may be big (IO like HTTP call), or may be
  small, but still noticeable (new UI window creation). The aim of
  this research project is to provide framework which could be used in
  order to minimize latency by:
    - Pre-fetch - we cannot do anything about speed of light and
      latency NY <> Sydney would never be less than ~70ms. But we can
      fetch the content **before** user has requested it
    - Partial load - only load what user can see at first, load the
      rest later on
    - Prediction - what user going to do/request next? What is going
      to happen after it? What user **want** when he runs the
      application
