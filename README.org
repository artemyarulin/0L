* zerol - user interface rule based engine

Research project about applying rule based systems into client side
application

** Key points

*** Separation from underlaying platform

As we are representing IO as data and IO handlers is suppied
separately from rules we can run our application across different
platforms. Having internal representation of UI tree also helps and
abstracts core part of the app from UI frameworks details

*** Easy testing

Our rules are pure functions. Having internal representation of UI
allows us to do UI testing easily

- [ ] How can we send additional events? How not so send it too soon?

*** Cache invalidation

Client side are often operating with cached representation of data
while actual data is stored somewhere else. Issue is that we need to
be able to define rules which will invalidate data in certain
cases. We can do it by associating additional metadata information
about source and age of pices of data

- [ ] While data representation is good enough, accessing ~:age~ data
  is very limited
- [ ] How can we represent relation between data? Otherwise cache
  would not be consistent

*** Prefetch data

Having simple logic of emitting new IO from data makes it easy to
produce pre-fetch requests. Additional information about IO priorities
makes it easy to queue requests in a most performant way

- [ ] ~:accessible~ priority - how can we follow what is currently
  rendered on screen?

*** Canceling IO and removing UI

All IO and UI has to be bounded to data. If data got changed and IO is
not emitted anymore - it will be canceled automatically, same for
UI. It makes IO follow actual application state and data automatically

*** Optimistic updates

- [ ] How does it look like?

*** Session persistence

- [ ] How can we save only the data that we actually need

*** Multiple app entry points

As UI and IO is just a function from data it become trivial to start
application with different starting state

*** Instant run by using partial load

- [ ] Can we somehow load only the data which is visible currently to user?

*** Prediction

- [ ] What can we do based on data history that we have?

*** Tracability

We store all UI, IO and data changes. In this case logging in most of
the cases is not needed

- [ ] How can we attach remote logger for example? As a rule or somehow differently?
- [ ] Rule monitoring - how can we gather information about certain
  rule execution and store it remotly on our server for statistics?

** Terms
- ~rule~ - Function that subscribes to certinan subset of ~state~,
  once it changed - processes it and may return new piece of ~state~
- ~state~ - Current state which represents all available data, ui and
  happening io
- ~io~ - All side effect that are executing currently. No IO should be
  possible outside of that
- ~ui~ - Current representation of UI that going to be rendered by
  rendering engine
- ~data~ - Normalized plain data. Essentially it's just a cache with
  hot data while actual data is saved on server/database/etc.
- ~age~ - Additional metadata about pieace of ~data~: When was it
  fetched, from where, how it may be persisted, etc.

** References

*** Papers
- [[http://alumni.media.mit.edu/~jorkin/GOAP_draft_AIWisdom2_2003.pdf][Applying Goal-Oriented Action Planning to Games]]
- [[http://web.stanford.edu/~ouster/cgi-bin/papers/rules-atc15][Experience with Rules-Based Programming for Distributed, Concurrent, Fault-Tolerant Code]]
- [[http://www.ece.cmu.edu/~ece740/f11/lib/exe/fetch.php%3Fmedia%3Dwiki:lectures:onur-740-fall11-lecture24-prefetching-afterlecture.pdf][Computer Architecture Lecture 24: Prefetching]]

*** Articles
- [[https://awelonblue.wordpress.com/2012/07/01/why-not-events/][Why not events]]

*** Books
- [[http://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910][Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp]]

*** Talks
- [[https://www.youtube.com/watch?v=ajX09xQ_UEg][Game development development]] - dependency graph looks relly nice

*** Projects
- [[https://www.haskell.org][Haskell]] - for teaching me that IO has to be handled carefully
- [[https://github.com/omcljs/om][om-next]] - components queries is great idea
- [[https://github.com/reactjs/redux][redux]] - almost perfect solution, used as a starting point
- [[https://github.com/artemyarulin/om-next-ios-pure][om-next-ios-pure]] - previous attempt to solve the issue without actually thinking about it
