* zerol - user interface rule based engine

Research project about applying rule based systems into client side
application

** Status

Early development, while engine works and most important concepts are
defined the implementation itself is very bad and ugly. It's fine
because most valuable thing are tests and use cases

** References

*** Papers
- [[http://alumni.media.mit.edu/~jorkin/GOAP_draft_AIWisdom2_2003.pdf][Applying Goal-Oriented Action Planning to Games]]
- [[http://web.stanford.edu/~ouster/cgi-bin/papers/rules-atc15][Experience with Rules-Based Programming for Distributed, Concurrent, Fault-Tolerant Code]]
- [[http://www.ece.cmu.edu/~ece740/f11/lib/exe/fetch.php%3Fmedia%3Dwiki:lectures:onur-740-fall11-lecture24-prefetching-afterlecture.pdf][Computer Architecture Lecture 24: Prefetching]]
- [[https://web.fe.up.pt/~apaiva/PhD/PhDGUITesting.pdf][Automated Specification-Based Testing of Graphical User Interfaces]]

*** Articles
- [[https://awelonblue.wordpress.com/2012/07/01/why-not-events/][Why not events]]

*** Books
- [[http://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910][Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp]]

*** Talks
- [[https://www.youtube.com/watch?v=ajX09xQ_UEg][Game development development]] - dependency graph looks relly nice
- [[https://www.youtube.com/watch?v=5V1ynVyud4M][Eve]] - normalized data;IO as data;rules, many similarities
- [[https://www.youtube.com/watch?v=R2Aa4PivG0g][I See What You Mean]] - logic rules, notion of time

*** Projects
- [[https://www.haskell.org][Haskell]] - for teaching me that IO has to be handled carefully
- [[https://github.com/omcljs/om][om-next]] - components queries is great idea
- [[https://github.com/reactjs/redux][redux]] - almost perfect solution, used as a starting point
- [[https://github.com/artemyarulin/om-next-ios-pure][om-next-ios-pure]] - previous attempt to solve the issue without actually thinking about it

** Questions & ideas

- Proposal for standartisation of IO:

#+BEGIN_SRC clojure
{:type :http
 :error (ex-info "Some message" {:add-param1 "add-param-value1"})
 :options io-options
 :success {:status 200 :headers {} :body "Something"}
 :status [nil | :progress | :error | :success]
 :cancel (fn[])}
#+END_SRC

- In case of a crash - what should we do?
- Zerol should be answer WHY it did something
- Zerol should have a notion of time. Without it wouldn't be able to
  answer ~WHY~ quesiont and make cache invalidation

  - Rough idea - new root key ~time~ which would look like:
#+BEGIN_SRC clojure

{:hystory [[where why what prev]
          [T1 query-caused-change query-changed prev-value]]}

;; where/T1,T2...TN - Where new value appeared. It could be point in time (simple timestamp) or more complex location like [session-id,remote,timestamp]
;; why/query-caused-change - WHY something got changed, what caused that
;; what/query-changed - WHAT got changed
;; prev/prev-data-value - Previous query value

;; Example with counter

{:time (['T3 [:ui :button :click?] [:data :counter] 8]
        ['T2 [:ui :button :click?] [:data :counter] 7]
        ['T1 [:ui :button :click?] [:data :counter] 6]
        ['T0 [] [] {:data {:counter 5} :ui {:button {:click? false}}}]]}

;; Now we can ask why questions

> (why [:data :counter])
Because:
 'T3 [:ui :button :click?] changed it from 7 to 8
 'T2 [:ui :button :click?] changed it from 6 to 7
 'T1 [:ui :button :click?] changed it from 5 to 6
 'T0 initialized it with 5

#+END_SRC
- Like Datomic we should be able to ask ~what-if~ question, meaning do
  temp change on state following by render. It will help during manual
  testing for REPL. More awesome idea - take existing point in history
  and branch there. Use case: App did IO and rendered it. What-if
  server returned different data?
